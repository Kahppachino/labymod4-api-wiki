{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LabyMod4 API Wiki Click here to get to the wiki of our new addon API. Have you found something missing from this wiki that you think is important, or are you unhappy with something? Please fork our wiki repository, add/improve it and create a pull request here .","title":"LabyMod4 API Wiki"},{"location":"#labymod4-api-wiki","text":"Click here to get to the wiki of our new addon API. Have you found something missing from this wiki that you think is important, or are you unhappy with something? Please fork our wiki repository, add/improve it and create a pull request here .","title":"LabyMod4 API Wiki"},{"location":"pages/addon/","text":"With LabyMod 4 we've improved the way to develop addons. You now have one project per addon; this allows you to write version-independent code in the same project as version-dependent code without needing to copy & paste the version-independent code for every version. Here are some of the changes with our new Addon API: With our brand new Activity System, you can easily create and theme custom screens without needing to know how to use OpenGL More events for almost every occasion that behave like server-side events Improved way to create and use configurations Easy internationalization Mixin for bytecode manipulation in every version Easier setup and debugging of the addon As of now, you'll have to manually update your build.gradle.kts when we update your Gradle plugin or support a new Minecraft version. If you want to stay up to date at any time or if you have any questions regarding our Addon API, please feel free to join our development Discord . Have you found something missing from this wiki that you think is important, or are you unhappy with something? Please fork our wiki repository, add/improve it and create a pull request here .","title":"Introduction"},{"location":"pages/addon/additional-infos/","text":"Here you can find some information about things that didn't fit anywhere else. Why Is the Naming on Some of Our Methods So Weird? We've decided to change how we name our getters & setters. The \"established\" naming for getters would be getSomething() , but we've decided as an \"internal naming convention\" that getters that can't return null and return a type created by us don't have the get prefix but instead are just called by their name. So instead of for example getMinecraft() you'll only find minecraft() . Setters would normally have the prefix set . But if the setter is returning the same type of the class it is in; the set prefix will also be removed (this is most common in builders, so for example, in our renderers. instead of setPos(x, y) , you'll only find pos(x, y) ).","title":"Additional Information"},{"location":"pages/addon/additional-infos/#why-is-the-naming-on-some-of-our-methods-so-weird","text":"We've decided to change how we name our getters & setters. The \"established\" naming for getters would be getSomething() , but we've decided as an \"internal naming convention\" that getters that can't return null and return a type created by us don't have the get prefix but instead are just called by their name. So instead of for example getMinecraft() you'll only find minecraft() . Setters would normally have the prefix set . But if the setter is returning the same type of the class it is in; the set prefix will also be removed (this is most common in builders, so for example, in our renderers. instead of setPos(x, y) , you'll only find pos(x, y) ).","title":"Why Is the Naming on Some of Our Methods So Weird?"},{"location":"pages/addon/troubleshoot/","text":"Common mistakes and errors with possible solutions are explained on this page. If you have an issue that is described here, please read carefully. If the approach to resolving your issue doesn't work feel free to ask for help on our development Discord . If you need help from others, please always keep in mind that they're human and don't always answer right away and think about what is written on NoHello.net . The LabyMod API Doesn't Load It can occur that the LabyMod 4 Addon API doesn't load after a restart (or just a Gradle reload) while Gradle prints no errors. If this happens to you, try to delete the build-data.txt in the project root folder and refresh Gradle. My LSS StyleSheet Doesn't load If it can happen that the LSS StyleSheet doesn't load, this is most commonly caused by a forgotten or misplaced semicolon ( ; ) or curly bracket ( { , } ); the affected line should be printed to your log. Try to search for those two cases. If you cannot find anything, feel free to ask for help on our development Discord and provide your LSS StyleSheet .","title":"Troubleshoot"},{"location":"pages/addon/troubleshoot/#the-labymod-api-doesnt-load","text":"It can occur that the LabyMod 4 Addon API doesn't load after a restart (or just a Gradle reload) while Gradle prints no errors. If this happens to you, try to delete the build-data.txt in the project root folder and refresh Gradle.","title":"The LabyMod API Doesn't Load"},{"location":"pages/addon/troubleshoot/#my-lss-stylesheet-doesnt-load","text":"If it can happen that the LSS StyleSheet doesn't load, this is most commonly caused by a forgotten or misplaced semicolon ( ; ) or curly bracket ( { , } ); the affected line should be printed to your log. Try to search for those two cases. If you cannot find anything, feel free to ask for help on our development Discord and provide your LSS StyleSheet .","title":"My LSS StyleSheet Doesn't load"},{"location":"pages/addon/activities/activity/","text":"Activities are an easy way to create custom screens, and the best part: you don't need to know OpenGL to create most activities. Only if you want to display something truly custom, knowing OpenGL could be beneficial. However, it still wouldn't be much of a problem if you don't because you have many other possibilities to render anything you want. In the following pages, we will explain how to create custom activities, create and use widgets in your Activities, and theme them with LSS. It can be a bit much to take in at first, but it's worth it. Examples are shown on every page; you will find a link to the section with the example on every page within the first paragraphs. Click here to see the first example. Important Note Remember that we're explaining the Activity System in multiple steps. On this page, we will explain how to create bare Activities without any widgets or LSS. This is for example purposes only; we highly recommend using Widgets and LSS in your Activities, as the system is not optimized for bare Activities. If you create custom screens, in order to be accepted in our addon store, your screens need to be created with this system, and they need to support theming. Creating a Bare Activity All you need to do to create an Activity is create a new class and inherit either SimpleActivity or Activity . The SimpleActivity and Activity only have one difference. By inheriting SimpleActivity , your Activity renders the default theme background; by inheriting just Activity , you'll have an empty Activity that you can 100% customize. For our example, we'll be inheriting the SimpleActivity as we register it as a NavigationElement (so it will be displayed as another tab in the navigation). After we inherit the Activity superclass (or one of its extensions), we need to implement the renew method. In most cases, just returning a new instance of your Activity will do enough; in some cases, you might want to set the fields of your current activity instance to the new one, as the user's progress inside the Activity might be lost otherwise. Now we need to add the annotation at the top of our class, and the Activity will open. In this case, we want to render a text at the center of the screen, and as we are creating a bare Activity, we'll overwrite the render method. (please keep in mind that the super call has to be at the head of the method. Otherwise, our text will be rendered beneath the background). All we have to do now is to get the bounds of the Activity by declaring this.bounds() as a local variable (the bounds represent the position and size of activities and widgets - more on that in the part about LSS). Then we need get the TextRenderer by calling this.labyAPI.renderPipeline().textRenderer() as we will render our text with that renderer. Now to the rendering, apply your text to the renderer by using the setter text ; our text is the String \"I am a bare rendered example text\" , so we use textRenderer.text(\"I am a bare rendered example text\") ; after that, we set our position with the bounds we got before. As we want the text centered we need the centerX and centerY float and set them via textRenderer.pos(bounds.getCenterX(), bounds.getCenterY()) . We could theoretically render it now, but we want to adjust the renderer a bit. As of now, the text would start at the centered x position, but we want it centered, so we add textRenderer.centered(true) . Now, as this text will be rendered in a menu, we don't want a shadow; all we need to do to remove the shadow is add textRenderer.shadow(false) , maybe add a bit of color with textRenderer.color(Color.ORANGE.getRGB()) . Now, as all is set as we want, we can call textRenderer.render(stack) , and we are finished. Bare Activity Result Looking back at what we just wrote, this is what the code and result would look like: ExampleBareActivity Result @AutoActivity public class ExampleBareActivity extends SimpleActivity { @Override public void render ( Stack stack , MutableMouse mouse , float partialTicks ) { super . render ( stack , mouse , partialTicks ); Bounds bounds = this . bounds (); TextRenderer textRenderer = this . labyAPI . renderPipeline (). textRenderer (); textRenderer . text ( \"I am a bare rendered example text\" ) . pos ( bounds . getCenterX (), bounds . getCenterY ()) . centered ( true ) . shadow ( false ) . color ( Color . ORANGE . getRGB ()) . render ( stack ); } @Override public < T extends LabyScreen > @Nullable T renew () { return new ExampleBareActivity (). generic (); } }","title":"What are Activities?"},{"location":"pages/addon/activities/activity/#creating-a-bare-activity","text":"All you need to do to create an Activity is create a new class and inherit either SimpleActivity or Activity . The SimpleActivity and Activity only have one difference. By inheriting SimpleActivity , your Activity renders the default theme background; by inheriting just Activity , you'll have an empty Activity that you can 100% customize. For our example, we'll be inheriting the SimpleActivity as we register it as a NavigationElement (so it will be displayed as another tab in the navigation). After we inherit the Activity superclass (or one of its extensions), we need to implement the renew method. In most cases, just returning a new instance of your Activity will do enough; in some cases, you might want to set the fields of your current activity instance to the new one, as the user's progress inside the Activity might be lost otherwise. Now we need to add the annotation at the top of our class, and the Activity will open. In this case, we want to render a text at the center of the screen, and as we are creating a bare Activity, we'll overwrite the render method. (please keep in mind that the super call has to be at the head of the method. Otherwise, our text will be rendered beneath the background). All we have to do now is to get the bounds of the Activity by declaring this.bounds() as a local variable (the bounds represent the position and size of activities and widgets - more on that in the part about LSS). Then we need get the TextRenderer by calling this.labyAPI.renderPipeline().textRenderer() as we will render our text with that renderer. Now to the rendering, apply your text to the renderer by using the setter text ; our text is the String \"I am a bare rendered example text\" , so we use textRenderer.text(\"I am a bare rendered example text\") ; after that, we set our position with the bounds we got before. As we want the text centered we need the centerX and centerY float and set them via textRenderer.pos(bounds.getCenterX(), bounds.getCenterY()) . We could theoretically render it now, but we want to adjust the renderer a bit. As of now, the text would start at the centered x position, but we want it centered, so we add textRenderer.centered(true) . Now, as this text will be rendered in a menu, we don't want a shadow; all we need to do to remove the shadow is add textRenderer.shadow(false) , maybe add a bit of color with textRenderer.color(Color.ORANGE.getRGB()) . Now, as all is set as we want, we can call textRenderer.render(stack) , and we are finished.","title":"Creating a Bare Activity"},{"location":"pages/addon/activities/activity/#bare-activity-result","text":"Looking back at what we just wrote, this is what the code and result would look like: ExampleBareActivity Result @AutoActivity public class ExampleBareActivity extends SimpleActivity { @Override public void render ( Stack stack , MutableMouse mouse , float partialTicks ) { super . render ( stack , mouse , partialTicks ); Bounds bounds = this . bounds (); TextRenderer textRenderer = this . labyAPI . renderPipeline (). textRenderer (); textRenderer . text ( \"I am a bare rendered example text\" ) . pos ( bounds . getCenterX (), bounds . getCenterY ()) . centered ( true ) . shadow ( false ) . color ( Color . ORANGE . getRGB ()) . render ( stack ); } @Override public < T extends LabyScreen > @Nullable T renew () { return new ExampleBareActivity (). generic (); } }","title":"Bare Activity Result"},{"location":"pages/addon/activities/lss/","text":"If you've worked with CSS before, LSS shouldn't be all too new; both share a similar basic syntax. We have implemented LSS as a system to design and theme responsive GUIs (Screens) conveniently; no more OpenGL hustle, just Activities, Widgets, and LSS. LSS in a Nutshell The main thing you need to know about LSS is that while you add LSS StyleSheets to your Activity, you can't manipulate Activities directly, only the Widgets inside of that Activity. A list of all Widgets delivered with the API can be found here . CSS and LSS have a very similar syntax, but here are some of their differences: CSS has classes, and LSS has ids that can be added to Widgets directly in the Activities Java code. In CSS, you can declare the type. You can do the same in LSS; there is one thing to keep in mind: if the name of a Widget ends with the suffix \"Widget\", the suffix gets removed (so, for example, Component instead of ComponentWidget or Icon instead of IconWidget ). LSS has no types like p for pixels, etc. LSS always works with relative pixels (1 = one pixel on GUI scale 1, four pixels on GUI scale 2, and 16 pixels on GUI scale 3) Creating Activities with LSS Looking back at the last page , we created an Activity with a ComponentWidget but without LSS. We'll again use the last page's result to make it work with LSS. We start by deleting the postStyleSheetLoad method, which we used before to set the position of our Widget. As LSS is doing that now, we no longer need this method. Now we head to our resources folder in the core module ( src/main/resources/ ) and go to (or create) the following folder structure: assets/example/themes/vanilla/lss/ (replace example with the namespace of your addon). After that, create a new file called example.lss . Now the magic part: as we didn't set an id, we'll use the type. We have a ComponentWidget in our Activity, so we're going to type Component { into the first line. As we want our Component centered, we'll add left: 50%; and top: 50%; to the following lines. If we were doing that, the Component would start at 50% of the screen each, adding alignment-x: center; and alignment-y: center; as the following lines. This will adjust the anchor point of the Widget to its center, so 50% from the left will be exactly at the center of the Widget. The last thing we'll need to do here is close the block with }, and we're done. All we have to do now is go back to our Activity that uses LSS, add the Link annotation above and add \"example.lss\" as the annotation's argument. Theoretically, we're done. But there are a few things left that we can do. For once, we can remove the field componentWidget , as we don't need the Widget anywhere else anymore. We can also remove the argument NamedTextColor.GOLD from the ComponentWidget's constructor call and add text-color: gold; to our LSS file. Now, there is one more thing we can do, and that is to add an id to our Widget. We'll do this by just calling componentWidget.addId(\"test-widget\") and replacing Component in our LSS StyleSheet with .test-widget . This will be very important when creating complex Activities so that blocks for the same Widget don't overwrite each other. And we're done. You can debug your Activity by pressing CTRL + D and pressing ARROW RIGHT until you see the name of your Activity if ever something doesn't work like expected. LSS Activity Result Like before, this is what the code we described above would look like: ExampleLssActivity example.lss Result @AutoActivity @Link ( \"example.lss\" ) public class ExampleLssActivity extends SimpleActivity { @Override public void initialize ( Parent parent ) { super . initialize ( parent ); ComponentWidget componentWidget = ComponentWidget . text ( \"I am an example text rendered with a ComponentWidget set via LSS\" ); componentWidget . addId ( \"test-widget\" ); this . document (). addChild ( componentWidget ); } @Override public < T extends LabyScreen > @Nullable T renew () { return new ExampleLssActivity (). generic (); } } . test-widget { left : 50 % ; top : 50 % ; alignment-x : center ; alignment-y : center ; text-color : gold ; } Create Widgets With LSS todo: write Injecting Blocks Into Other StyleSheets todo: write","title":"Understand LSS"},{"location":"pages/addon/activities/lss/#lss-in-a-nutshell","text":"The main thing you need to know about LSS is that while you add LSS StyleSheets to your Activity, you can't manipulate Activities directly, only the Widgets inside of that Activity. A list of all Widgets delivered with the API can be found here . CSS and LSS have a very similar syntax, but here are some of their differences: CSS has classes, and LSS has ids that can be added to Widgets directly in the Activities Java code. In CSS, you can declare the type. You can do the same in LSS; there is one thing to keep in mind: if the name of a Widget ends with the suffix \"Widget\", the suffix gets removed (so, for example, Component instead of ComponentWidget or Icon instead of IconWidget ). LSS has no types like p for pixels, etc. LSS always works with relative pixels (1 = one pixel on GUI scale 1, four pixels on GUI scale 2, and 16 pixels on GUI scale 3)","title":"LSS in a Nutshell"},{"location":"pages/addon/activities/lss/#creating-activities-with-lss","text":"Looking back at the last page , we created an Activity with a ComponentWidget but without LSS. We'll again use the last page's result to make it work with LSS. We start by deleting the postStyleSheetLoad method, which we used before to set the position of our Widget. As LSS is doing that now, we no longer need this method. Now we head to our resources folder in the core module ( src/main/resources/ ) and go to (or create) the following folder structure: assets/example/themes/vanilla/lss/ (replace example with the namespace of your addon). After that, create a new file called example.lss . Now the magic part: as we didn't set an id, we'll use the type. We have a ComponentWidget in our Activity, so we're going to type Component { into the first line. As we want our Component centered, we'll add left: 50%; and top: 50%; to the following lines. If we were doing that, the Component would start at 50% of the screen each, adding alignment-x: center; and alignment-y: center; as the following lines. This will adjust the anchor point of the Widget to its center, so 50% from the left will be exactly at the center of the Widget. The last thing we'll need to do here is close the block with }, and we're done. All we have to do now is go back to our Activity that uses LSS, add the Link annotation above and add \"example.lss\" as the annotation's argument. Theoretically, we're done. But there are a few things left that we can do. For once, we can remove the field componentWidget , as we don't need the Widget anywhere else anymore. We can also remove the argument NamedTextColor.GOLD from the ComponentWidget's constructor call and add text-color: gold; to our LSS file. Now, there is one more thing we can do, and that is to add an id to our Widget. We'll do this by just calling componentWidget.addId(\"test-widget\") and replacing Component in our LSS StyleSheet with .test-widget . This will be very important when creating complex Activities so that blocks for the same Widget don't overwrite each other. And we're done. You can debug your Activity by pressing CTRL + D and pressing ARROW RIGHT until you see the name of your Activity if ever something doesn't work like expected.","title":"Creating Activities with LSS"},{"location":"pages/addon/activities/lss/#lss-activity-result","text":"Like before, this is what the code we described above would look like: ExampleLssActivity example.lss Result @AutoActivity @Link ( \"example.lss\" ) public class ExampleLssActivity extends SimpleActivity { @Override public void initialize ( Parent parent ) { super . initialize ( parent ); ComponentWidget componentWidget = ComponentWidget . text ( \"I am an example text rendered with a ComponentWidget set via LSS\" ); componentWidget . addId ( \"test-widget\" ); this . document (). addChild ( componentWidget ); } @Override public < T extends LabyScreen > @Nullable T renew () { return new ExampleLssActivity (). generic (); } } . test-widget { left : 50 % ; top : 50 % ; alignment-x : center ; alignment-y : center ; text-color : gold ; }","title":"LSS Activity Result"},{"location":"pages/addon/activities/lss/#create-widgets-with-lss","text":"todo: write","title":"Create Widgets With LSS"},{"location":"pages/addon/activities/lss/#injecting-blocks-into-other-stylesheets","text":"todo: write","title":"Injecting Blocks Into Other StyleSheets"},{"location":"pages/addon/activities/themes/","text":"One of the key advantages of our Activity System with LSS over OpenGL is that you can easily theme your Activities with LSS. With OpenGL you'd have to rewrite the screen for every theme you want to support. With LSS, just like with CSS, you can just have an LSS StyleSheet for each theme. You can also create your own theme. All that is explained on this page. Important Note Creating own themes doesn't work as of now. But we're working on it! How Themes Work todo: write","title":"Theming"},{"location":"pages/addon/activities/themes/#how-themes-work","text":"todo: write","title":"How Themes Work"},{"location":"pages/addon/activities/widgets/","text":"Widgets are a valuable and easy way to customize your Activities and are the backbone of every themeable Activity. Use Widgets in Activities This part will show you how to use and integrate Widgets into your Activity. Looking back at our bare Activity example, we rendered the text \"I am a bare rendered example text\" , so we'll be using a ComponentWidget just this time with the text \"I am an example text rendered with a ComponentWidget\" . We're building onto the code from the previous example so if you haven't already gone through it, we recommend taking a look at it here . Important Note Remember that we're explaining the Activity System in multiple steps. This part of the page will explain how to create Activities with Widgets but without LSS. This is for example purposes only; we highly recommend using Widgets and LSS in your Activities, as the system is not optimized for Widgets without LSS. It is possible but don't expect your code to work forever; there is a high chance that the methods you use will be deprecated at any time. Looking back at the bare Activity example, we remove the render method overwrite, as we don't need that anymore because the ComponentWidget will render the text for us. Now we overwrite the initialize method. Keep in mind that the super call has to be at the head of the method body. The method will be called any time the window is resized, the Activity is manually reloaded, or when the Activity was opened. Then we create a new ComponentWidget. In this case, we will create a non-translatable ComponentWidget by calling ComponentWidget.text and declare our text as the first parameter. Because we want our text to be colored, we'll set the color color of our choice as the second parameter, in this case, Gold. The call should look like this in the end: ComponentWidget.text(\"I am an example text rendered with a ComponentWidget\", NamedTextColor.GOLD) . Now we just declare it as a field and call this.document().addChild(this.componentWidget) as this will add the ComponentWidget to our Activity. Theoretically, we could start the client, and our text would be rendered. But we haven't set the position yet. We'll only look at LSS in the next part, so we need to set the position with our Java code. To do this, we need to overwrite the protected void postStyleSheetLoad and again keep the super call as it notifies all child widgets that the style sheets have been loaded. We don't use those yet, but we leave the call in anyways. This method is called when all style sheets have been loaded and applied, just as the name suggests. Now we get the bounds of our activity with this.bounds() and the bounds of our ComponentWidget via this.componentWidget.bounds() and set the position of said widget with widgetBounds.setPosition(activityBounds.getCenterX(), activityBounds.getCenterY() . As we want the ComponentWidget to be centered we need also to add this.componentWidget.alignmentX().set(WidgetAlignment.CENTER) and this.componentWidget.alignmentY().set(WidgetAlignment.CENTER) this centers the Widget horizontally and vertically. Widget Activity Result Like with the bare Activity, this is what the code we described above would look like: ExampleBareActivity Result @AutoActivity public class ExampleWidgetActivity extends SimpleActivity { private ComponentWidget componentWidget ; @Override public void initialize ( Parent parent ) { super . initialize ( parent ); this . componentWidget = ComponentWidget . text ( \"I am an example text rendered with a ComponentWidget\" , NamedTextColor . GOLD ); this . document (). addChild ( this . componentWidget ); } @Override protected void postStyleSheetLoad () { super . postStyleSheetLoad (); Bounds activityBounds = this . bounds (); Bounds widgetBounds = this . componentWidgetBounds . bounds (); componentWidgetBounds . setPosition ( activityBounds . getCenterX (), activityBounds . getCenterY () ); this . componentWidget . alignmentX (). set ( WidgetAlignment . CENTER ); this . componentWidget . alignmentY (). set ( WidgetAlignment . CENTER ); } @Override public < T extends LabyScreen > @Nullable T renew () { return new ExampleWidgetActivity (). generic (); } } Create Your Own Widget You cannot only use the Widgets we created, but you can also create your own ones. This small example will show you how to create your first Widget and add it to your Activity. The result of our little example will be a widget that displays a player's head to the left and a player's name. This Widget will be applied in a vertical list with multiple entries. Important Note As it would be too complex to explain how to create a Widget without LSS, as of now you can only find an explanation on how to create Widgets here . All Widgets Below listed are all Widgets for use. They can be extended and modified for a more specific use case. Every Widget also has the LSS Properties from AbstractWidget Input Widgets Input Widgets are Widgets that allow direct user input. Button The ButtonWidget is an Input-Widget that performs a specific action (set with setPressable(Pressable) ) when pressed. It can be created with a String with ButtonWidget.text and a Component with ButtonWidget.component . The Widget has the following LSS properties: Everything from HorizontalListWidget (because the Button can have an Icon) icon Check Box The CheckBoxWidget is an Input-Widget that switches between two states ( CHECKED and UNCHECKED ) when pressed but can also have the state PARTLY , but that can only be set via setState(State) . It can be created with the default constructor (no arguments needed). The Widget has no own LSS properties. Color Picker The ColorPickerWidget is an Input-Widget that opens an Overlay when clicked where the user can select a specific color. It can be created via its constructor. The Widget has no own LSS properties. Dropdown The DropdownWidget is an Input-Widget that opens an Overlay when clicked in which the user can select an entry. The Widget is generic; you have to specify the type of the entries (preferably String or any Enum) as the argument. Entries can be added with add(GenericType) , addAll(GenericType[]) and addAll(List<GenericType>) . Translatable by calling translationKeyPrefix(String) , It can be created with the default constructor (no arguments needed). The Widget has no own LSS properties. Keybind The KeybindWidget is an Input-Widget that allows the user to set a specific Key. It also accepts mouse buttons when expressly set with acceptMouseButtons(Boolean) . It can be created via its constructor. The Widget has the same LSS properties as TextFieldWidget . Multi Keybind The MultiKeybindWidget is an Input-Widget that allows users to set multiple keys simultaneously. It can be created via its constructor. The Widget has the same LSS properties as TextFieldWidget . Slider The SliderWidget is an Input-Widget that allows users to select a specific number inside a set range (default is 0-100). The Range can be set with range(Float, Float) and the steps with steps(Float) . It can be created via its constructor. The Widget has no own LSS properties. Switch The SwitchWidget is an Input-Widget that allows the user to enable or disable a certain feature. Can be created with SwitchWidget.create(Switchable) , SwitchWidget.text(String, String, Switchable) or SwitchWidget.translatable(String, String, Switchable) . The Widget has no own LSS properties. Text Field The TextFieldWidget is an Input-Widget that allows the user to type in any text. Typed-in text can be validated by calling validator(Predicate) . It can be created with the default constructor (no arguments needed). The Widget has the following LSS properties: cursor-color - the color of the cursor (default is white ) font-size - size of the text (default is 1.0 ) mark-color - the color of the marked background (default is -1 ) mark-text-color - color of the marked text (default is rgb(32, 32, 170) ) place-holder-color - the color of the placeholder text (default is dark-gray ) text-alignment-x - either left , center or right (default is left ) text-alignment-y - either top , center or bottom (default is top ) text-color - the color of the text (default is white ) type - either default or vanilla-window (default is default ) Grid Widgets Grid Widgets are Widgets that automatically set the position of children in a specific way. Horizontal List The HorizontalListWidget is a Grid-Widget that displays all its entries in a horizontal list. Add entries by executing addEntry(Widget) . It can be created with the default constructor (no arguments needed). The Widget has the following LSS properties: layout - the layout of the list - either spread , fill or stack (default is stack ) space-between-entries - the space between each entry (default is 1 ) Tiles Grid The TilesGridWidget is a Grid-Widget that displays all its tiles in a specific grid that can be set via LSS. The Widget is generic; you have to specify the type of widgets you want to add as the argument. Tiles can be added via addTile(GenericType) . It can be created with the default constructor (no arguments needed). The Widget has the following LSS properties: space-between-entries - the space between each entry (default is 0 ) tile-height - the height of the tiles - set to -1 to make the tiles a square (default is -1 ) tiles-per-line - the number of tiles per line (default is 3 ) Vertical List The VerticalListWidget is a Grid-Widget that displays all its entries in a vertical list. The Widget is generic; you have to specify the type of widgets you want to add as the argument. Children can be added via addChild(GenericType) . It can be created with the default constructor (no arguments needed). The Widget has the following LSS properties: list-alignment - the alignment the children should have inside the list - either top , center or bottom (default is top ) list-order - the order of the children - either normal or reverse (default is normal ) overwrite-width - if the width of children should be set to the with of the list (default is true ) render-out-of-bounds - if the children should be rendered out of bounds, it makes sense if the Widget is inside a ScrollWidget (default is false ) selectable - if the children should be selected on click (default is false ) space-between-entries - the space between each entry (default is 1 ) squeeze-height - if children that would have been rendered out of bounds should be squeezed to stay in the bounds (default is false - use with caution!) Utility Widgets Utility Widgets are Widgets that can be useful for any Activity. Component The ComponentWidget is a Utility-Widget that displays any Component. Can be created with ComponentWidget.text , Componentwidget.i18n and ComponentWidget.component . Each factory method has multiple implementations. The Widget has the following LSS properties: allow-colors - if the color of the component should be used (default is true ) font-size - how much the component should be scaled (default is 1.0 ) line-spacing - the spacing between multiple lines if overflow-strategy is wrap (default is 0.0 ) max-lines - the number of maximum lines that should be displayed if overflow-strategy is wrap (default is 0 , set to 0 to disable) overflow-strategy - the strategy that is applied when text is longer than the bounds allow - either wrap or clip (default is wrap ) scale-to-fit - if the component should be scaled to fit the bounds if it would overflow (default is false ) shadow - if the component should have a shadow (default is true ) text-color - the color of the component (default is -1 , set to -1 to disable) Div The DivWidget is a Utility-Widget that does nothing special, as it is just an implementation of SimpleWidget and can be used for creating simple containers without automatic alignment. It can be created with the default constructor (no arguments needed). The Widget has no own LSS properties. Fading The FadingWidget is a Utility-Widget that slowly fades out at a specific timestamp. It can be created with either FadingWidget.until(Widget, Long) to specify a timestamp or FadingWidget.forMillis(Widget, Long) to specify the milliseconds until the Widget fades. The Widget has no own LSS properties. Hr The HrWidget is a Utility-Widget that acts as a separator between Widgets. It renders a line with the size of the Widget's inner bounds (only in the Fancy Theme!) It can be created with the default constructor (no arguments needed). The Widget has no own LSS properties. Icon The IconWidget is a Utility-Widget that renders an Icon . It can be created via its constructor. The Widget has the following LSS properties: icon - the rendered Icon (the argument sets the default value in the constructor) color - the color of the Icon (default is -1 ) object-fit - the fit of the Icon inside the Widget's bounds - either fill , contain , cover , scale-down or none (default is fill ) clickable - if the Icon should be slightly zoomed when hovered (default is false ) Screen Renderer The ScreenRendererWidget is a Utility-Widget that renders any Activity inside the bounds of the Widget. It can be created with its constructor. Calling the default constructor doesn't forward the style. The Widget has the following LSS properties: interactable - if the user should be able to interact with the rendered screen (default is true ) Scroll The ScrollWidget is a Utility-Widget that allows scrolling Widgets vertically (preferably VerticalListWidget or TilesGridWidgets ). It automatically adds a ScrollbarWidget as its second child. The child has to have their height set to fit-content , and the ScrollWidget 's height has to be fixed for everything to work. Can be created with either new ScrollWidget(VerticalListWidget) or new ScrollWidget(Widget, ListSession<>) . The Widget has the following LSS properties: enable-scroll-content - if content should be scrolled when dragging the mouse (default is false ) scrollSpeed - how fast the content should be scrolled (default is -1 , set to -1 to calculate the scroll speed automatically based on the number of children) child-align - where the content should be aligned - either top , center or bottom (default is top ) Scrollbar Abstract Widgets Abstract Widgets are not for direct use and are therefore intended exclusively for inheritance and extension. Abstract Widget The AbstractWidget is the main implementation of almost every Widget. The generic type declares the type of its children. The Widget and, therefore all inheriting Widgets have the following LSS properties (if no default value is specified, the default value is null , and the property has to be set to take effect) As there are so many, they are split into different sections: Positioning (Bounds) Every property (except the padding and margin allrounder) in this section can also have a percentage. The width: 5% will result in the width being 5% of the parent's width. left - the relative left position to the parent top - the relative top position to the parent right - the relative right position to the parent bottom - the relative bottom position to the parent width - the width (can be a number but also fit-content or height ) height - the height (can be a number but also fit-content or width ) max-width - the maximum width (useful when the widget has no fixed width) max-height - the maximum height (useful when the Widget has no fixed height) min-width - the minimum width (useful when the Widget has no fixed width) min-height - the minimum height (useful when the Widget has no fixed height) padding - the padding (has to be this format: TOP RIGHT BOTTOM LEFT or just one number to set the same padding in all directions) padding-top - the padding at the top (default is 0.0 ) padding-right - the padding at the right (default is 0.0 ) padding-bottom - the padding at the bottom (default is 0.0 ) padding-left - the padding at the left (default is 0.0 ) margin - the margin (has to be this format: TOP RIGHT BOTTOM LEFT or just one number to set the same margin in all directions) margin-top - the margin at the top (default is 0.0 ) margin-right - the margin at the right (default is 0.0 ) margin-bottom - the margin at the bottom (default is 0.0 ) margin-left - the margin at the left (default is 0.0 ) alignment-x - the horizontal anchor point of the widget - either left , center or right (default is left ) alignment-y - the vertical anchor point of the widget - either top , center or bottom (default is top ) use-floating-point-position - if the position should use Float instead of Integer (default is false in Vanilla- and true in Fancy-Theme) fit-outer - if fit-content should be applied to the outer instead of the inner bounds of the children (default is false ) box-sizing - how the width and height should be calculated - either content-box or border-box (default is content-box ) Visual animation-duration - the duration of the animation - in milliseconds (default is 0 ) animation-timing-function - how animations should be interpolated - either linear , ease-in-out , ease-in or ease-out (default is ease-in-out ) background-color - the color of the background (default is 0, set to 0 to disable) background-dirt-brightness - the brightness of the dirt background (default is 32 ) filter - filters that should be applied - possible are blur(RADIUS) and stencil-background font-weight - the weight of the font opacity - the opacity - has to be between 0.0 and 1.0 (default is 1.0 ) render-children - if the children should be rendered (default is true ) renderer - which ThemeRenderer the Widget uses scale - the scale in which the Widget is rendered (default is 1.0 ) visible - if the widget is visible or not (default is true ) Behavioral always-focused - if the Widget should always have the attribute FOCUSED (default is false ) background-always-dirt - if the background should always stay dirt, even if ingame (default is false ) background-dirt-shift - the shift of the dirt background draggable - if the Widget can be dragged (default is false ) interactable - if the widget can be interacted with (default is true ) mouse-render-distance - in which distance to your mouse the Widget will get visible (default is 0.0 , set to 0.0 to disable) pressable - if clicking the widget fires the Pressable callback (default is true ) priority-layer - depending on what is set the Widget will be rendered before everything else or after - either very-back , back , normal , front , very-front (default is normal ) stencil - if the widget content should not be able out of bounds (default is false ) List Widget The ListWidget is the parent of every list like Widget. The Widget has no own LSS properties. Simple Widget The SimpleWidget inherits AbstractWidget and removes the generic. The Widget has no own LSS properties. Wrapped Widget The WrappedWidget is a \"pseudo Widget\" that wraps around its child and acts like it. The Widget has no LSS properties as it redirects everything to its child. deprecated!","title":"Use and Create Widgets"},{"location":"pages/addon/activities/widgets/#use-widgets-in-activities","text":"This part will show you how to use and integrate Widgets into your Activity. Looking back at our bare Activity example, we rendered the text \"I am a bare rendered example text\" , so we'll be using a ComponentWidget just this time with the text \"I am an example text rendered with a ComponentWidget\" . We're building onto the code from the previous example so if you haven't already gone through it, we recommend taking a look at it here . Important Note Remember that we're explaining the Activity System in multiple steps. This part of the page will explain how to create Activities with Widgets but without LSS. This is for example purposes only; we highly recommend using Widgets and LSS in your Activities, as the system is not optimized for Widgets without LSS. It is possible but don't expect your code to work forever; there is a high chance that the methods you use will be deprecated at any time. Looking back at the bare Activity example, we remove the render method overwrite, as we don't need that anymore because the ComponentWidget will render the text for us. Now we overwrite the initialize method. Keep in mind that the super call has to be at the head of the method body. The method will be called any time the window is resized, the Activity is manually reloaded, or when the Activity was opened. Then we create a new ComponentWidget. In this case, we will create a non-translatable ComponentWidget by calling ComponentWidget.text and declare our text as the first parameter. Because we want our text to be colored, we'll set the color color of our choice as the second parameter, in this case, Gold. The call should look like this in the end: ComponentWidget.text(\"I am an example text rendered with a ComponentWidget\", NamedTextColor.GOLD) . Now we just declare it as a field and call this.document().addChild(this.componentWidget) as this will add the ComponentWidget to our Activity. Theoretically, we could start the client, and our text would be rendered. But we haven't set the position yet. We'll only look at LSS in the next part, so we need to set the position with our Java code. To do this, we need to overwrite the protected void postStyleSheetLoad and again keep the super call as it notifies all child widgets that the style sheets have been loaded. We don't use those yet, but we leave the call in anyways. This method is called when all style sheets have been loaded and applied, just as the name suggests. Now we get the bounds of our activity with this.bounds() and the bounds of our ComponentWidget via this.componentWidget.bounds() and set the position of said widget with widgetBounds.setPosition(activityBounds.getCenterX(), activityBounds.getCenterY() . As we want the ComponentWidget to be centered we need also to add this.componentWidget.alignmentX().set(WidgetAlignment.CENTER) and this.componentWidget.alignmentY().set(WidgetAlignment.CENTER) this centers the Widget horizontally and vertically.","title":"Use Widgets in Activities"},{"location":"pages/addon/activities/widgets/#widget-activity-result","text":"Like with the bare Activity, this is what the code we described above would look like: ExampleBareActivity Result @AutoActivity public class ExampleWidgetActivity extends SimpleActivity { private ComponentWidget componentWidget ; @Override public void initialize ( Parent parent ) { super . initialize ( parent ); this . componentWidget = ComponentWidget . text ( \"I am an example text rendered with a ComponentWidget\" , NamedTextColor . GOLD ); this . document (). addChild ( this . componentWidget ); } @Override protected void postStyleSheetLoad () { super . postStyleSheetLoad (); Bounds activityBounds = this . bounds (); Bounds widgetBounds = this . componentWidgetBounds . bounds (); componentWidgetBounds . setPosition ( activityBounds . getCenterX (), activityBounds . getCenterY () ); this . componentWidget . alignmentX (). set ( WidgetAlignment . CENTER ); this . componentWidget . alignmentY (). set ( WidgetAlignment . CENTER ); } @Override public < T extends LabyScreen > @Nullable T renew () { return new ExampleWidgetActivity (). generic (); } }","title":"Widget Activity Result"},{"location":"pages/addon/activities/widgets/#create-your-own-widget","text":"You cannot only use the Widgets we created, but you can also create your own ones. This small example will show you how to create your first Widget and add it to your Activity. The result of our little example will be a widget that displays a player's head to the left and a player's name. This Widget will be applied in a vertical list with multiple entries. Important Note As it would be too complex to explain how to create a Widget without LSS, as of now you can only find an explanation on how to create Widgets here .","title":"Create Your Own Widget"},{"location":"pages/addon/activities/widgets/#all-widgets","text":"Below listed are all Widgets for use. They can be extended and modified for a more specific use case. Every Widget also has the LSS Properties from AbstractWidget","title":"All Widgets"},{"location":"pages/addon/activities/widgets/#input-widgets","text":"Input Widgets are Widgets that allow direct user input.","title":"Input Widgets"},{"location":"pages/addon/activities/widgets/#button","text":"The ButtonWidget is an Input-Widget that performs a specific action (set with setPressable(Pressable) ) when pressed. It can be created with a String with ButtonWidget.text and a Component with ButtonWidget.component . The Widget has the following LSS properties: Everything from HorizontalListWidget (because the Button can have an Icon) icon","title":"Button"},{"location":"pages/addon/activities/widgets/#check-box","text":"The CheckBoxWidget is an Input-Widget that switches between two states ( CHECKED and UNCHECKED ) when pressed but can also have the state PARTLY , but that can only be set via setState(State) . It can be created with the default constructor (no arguments needed). The Widget has no own LSS properties.","title":"Check Box"},{"location":"pages/addon/activities/widgets/#color-picker","text":"The ColorPickerWidget is an Input-Widget that opens an Overlay when clicked where the user can select a specific color. It can be created via its constructor. The Widget has no own LSS properties.","title":"Color Picker"},{"location":"pages/addon/activities/widgets/#dropdown","text":"The DropdownWidget is an Input-Widget that opens an Overlay when clicked in which the user can select an entry. The Widget is generic; you have to specify the type of the entries (preferably String or any Enum) as the argument. Entries can be added with add(GenericType) , addAll(GenericType[]) and addAll(List<GenericType>) . Translatable by calling translationKeyPrefix(String) , It can be created with the default constructor (no arguments needed). The Widget has no own LSS properties.","title":"Dropdown"},{"location":"pages/addon/activities/widgets/#keybind","text":"The KeybindWidget is an Input-Widget that allows the user to set a specific Key. It also accepts mouse buttons when expressly set with acceptMouseButtons(Boolean) . It can be created via its constructor. The Widget has the same LSS properties as TextFieldWidget .","title":"Keybind"},{"location":"pages/addon/activities/widgets/#multi-keybind","text":"The MultiKeybindWidget is an Input-Widget that allows users to set multiple keys simultaneously. It can be created via its constructor. The Widget has the same LSS properties as TextFieldWidget .","title":"Multi Keybind"},{"location":"pages/addon/activities/widgets/#slider","text":"The SliderWidget is an Input-Widget that allows users to select a specific number inside a set range (default is 0-100). The Range can be set with range(Float, Float) and the steps with steps(Float) . It can be created via its constructor. The Widget has no own LSS properties.","title":"Slider"},{"location":"pages/addon/activities/widgets/#switch","text":"The SwitchWidget is an Input-Widget that allows the user to enable or disable a certain feature. Can be created with SwitchWidget.create(Switchable) , SwitchWidget.text(String, String, Switchable) or SwitchWidget.translatable(String, String, Switchable) . The Widget has no own LSS properties.","title":"Switch"},{"location":"pages/addon/activities/widgets/#text-field","text":"The TextFieldWidget is an Input-Widget that allows the user to type in any text. Typed-in text can be validated by calling validator(Predicate) . It can be created with the default constructor (no arguments needed). The Widget has the following LSS properties: cursor-color - the color of the cursor (default is white ) font-size - size of the text (default is 1.0 ) mark-color - the color of the marked background (default is -1 ) mark-text-color - color of the marked text (default is rgb(32, 32, 170) ) place-holder-color - the color of the placeholder text (default is dark-gray ) text-alignment-x - either left , center or right (default is left ) text-alignment-y - either top , center or bottom (default is top ) text-color - the color of the text (default is white ) type - either default or vanilla-window (default is default )","title":"Text Field"},{"location":"pages/addon/activities/widgets/#grid-widgets","text":"Grid Widgets are Widgets that automatically set the position of children in a specific way.","title":"Grid Widgets"},{"location":"pages/addon/activities/widgets/#horizontal-list","text":"The HorizontalListWidget is a Grid-Widget that displays all its entries in a horizontal list. Add entries by executing addEntry(Widget) . It can be created with the default constructor (no arguments needed). The Widget has the following LSS properties: layout - the layout of the list - either spread , fill or stack (default is stack ) space-between-entries - the space between each entry (default is 1 )","title":"Horizontal List"},{"location":"pages/addon/activities/widgets/#tiles-grid","text":"The TilesGridWidget is a Grid-Widget that displays all its tiles in a specific grid that can be set via LSS. The Widget is generic; you have to specify the type of widgets you want to add as the argument. Tiles can be added via addTile(GenericType) . It can be created with the default constructor (no arguments needed). The Widget has the following LSS properties: space-between-entries - the space between each entry (default is 0 ) tile-height - the height of the tiles - set to -1 to make the tiles a square (default is -1 ) tiles-per-line - the number of tiles per line (default is 3 )","title":"Tiles Grid"},{"location":"pages/addon/activities/widgets/#vertical-list","text":"The VerticalListWidget is a Grid-Widget that displays all its entries in a vertical list. The Widget is generic; you have to specify the type of widgets you want to add as the argument. Children can be added via addChild(GenericType) . It can be created with the default constructor (no arguments needed). The Widget has the following LSS properties: list-alignment - the alignment the children should have inside the list - either top , center or bottom (default is top ) list-order - the order of the children - either normal or reverse (default is normal ) overwrite-width - if the width of children should be set to the with of the list (default is true ) render-out-of-bounds - if the children should be rendered out of bounds, it makes sense if the Widget is inside a ScrollWidget (default is false ) selectable - if the children should be selected on click (default is false ) space-between-entries - the space between each entry (default is 1 ) squeeze-height - if children that would have been rendered out of bounds should be squeezed to stay in the bounds (default is false - use with caution!)","title":"Vertical List"},{"location":"pages/addon/activities/widgets/#utility-widgets","text":"Utility Widgets are Widgets that can be useful for any Activity.","title":"Utility Widgets"},{"location":"pages/addon/activities/widgets/#component","text":"The ComponentWidget is a Utility-Widget that displays any Component. Can be created with ComponentWidget.text , Componentwidget.i18n and ComponentWidget.component . Each factory method has multiple implementations. The Widget has the following LSS properties: allow-colors - if the color of the component should be used (default is true ) font-size - how much the component should be scaled (default is 1.0 ) line-spacing - the spacing between multiple lines if overflow-strategy is wrap (default is 0.0 ) max-lines - the number of maximum lines that should be displayed if overflow-strategy is wrap (default is 0 , set to 0 to disable) overflow-strategy - the strategy that is applied when text is longer than the bounds allow - either wrap or clip (default is wrap ) scale-to-fit - if the component should be scaled to fit the bounds if it would overflow (default is false ) shadow - if the component should have a shadow (default is true ) text-color - the color of the component (default is -1 , set to -1 to disable)","title":"Component"},{"location":"pages/addon/activities/widgets/#div","text":"The DivWidget is a Utility-Widget that does nothing special, as it is just an implementation of SimpleWidget and can be used for creating simple containers without automatic alignment. It can be created with the default constructor (no arguments needed). The Widget has no own LSS properties.","title":"Div"},{"location":"pages/addon/activities/widgets/#fading","text":"The FadingWidget is a Utility-Widget that slowly fades out at a specific timestamp. It can be created with either FadingWidget.until(Widget, Long) to specify a timestamp or FadingWidget.forMillis(Widget, Long) to specify the milliseconds until the Widget fades. The Widget has no own LSS properties.","title":"Fading"},{"location":"pages/addon/activities/widgets/#hr","text":"The HrWidget is a Utility-Widget that acts as a separator between Widgets. It renders a line with the size of the Widget's inner bounds (only in the Fancy Theme!) It can be created with the default constructor (no arguments needed). The Widget has no own LSS properties.","title":"Hr"},{"location":"pages/addon/activities/widgets/#icon","text":"The IconWidget is a Utility-Widget that renders an Icon . It can be created via its constructor. The Widget has the following LSS properties: icon - the rendered Icon (the argument sets the default value in the constructor) color - the color of the Icon (default is -1 ) object-fit - the fit of the Icon inside the Widget's bounds - either fill , contain , cover , scale-down or none (default is fill ) clickable - if the Icon should be slightly zoomed when hovered (default is false )","title":"Icon"},{"location":"pages/addon/activities/widgets/#screen-renderer","text":"The ScreenRendererWidget is a Utility-Widget that renders any Activity inside the bounds of the Widget. It can be created with its constructor. Calling the default constructor doesn't forward the style. The Widget has the following LSS properties: interactable - if the user should be able to interact with the rendered screen (default is true )","title":"Screen Renderer"},{"location":"pages/addon/activities/widgets/#scroll","text":"The ScrollWidget is a Utility-Widget that allows scrolling Widgets vertically (preferably VerticalListWidget or TilesGridWidgets ). It automatically adds a ScrollbarWidget as its second child. The child has to have their height set to fit-content , and the ScrollWidget 's height has to be fixed for everything to work. Can be created with either new ScrollWidget(VerticalListWidget) or new ScrollWidget(Widget, ListSession<>) . The Widget has the following LSS properties: enable-scroll-content - if content should be scrolled when dragging the mouse (default is false ) scrollSpeed - how fast the content should be scrolled (default is -1 , set to -1 to calculate the scroll speed automatically based on the number of children) child-align - where the content should be aligned - either top , center or bottom (default is top )","title":"Scroll"},{"location":"pages/addon/activities/widgets/#scrollbar","text":"","title":"Scrollbar"},{"location":"pages/addon/activities/widgets/#abstract-widgets","text":"Abstract Widgets are not for direct use and are therefore intended exclusively for inheritance and extension.","title":"Abstract Widgets"},{"location":"pages/addon/activities/widgets/#abstract-widget","text":"The AbstractWidget is the main implementation of almost every Widget. The generic type declares the type of its children. The Widget and, therefore all inheriting Widgets have the following LSS properties (if no default value is specified, the default value is null , and the property has to be set to take effect) As there are so many, they are split into different sections:","title":"Abstract Widget"},{"location":"pages/addon/activities/widgets/#positioning-bounds","text":"Every property (except the padding and margin allrounder) in this section can also have a percentage. The width: 5% will result in the width being 5% of the parent's width. left - the relative left position to the parent top - the relative top position to the parent right - the relative right position to the parent bottom - the relative bottom position to the parent width - the width (can be a number but also fit-content or height ) height - the height (can be a number but also fit-content or width ) max-width - the maximum width (useful when the widget has no fixed width) max-height - the maximum height (useful when the Widget has no fixed height) min-width - the minimum width (useful when the Widget has no fixed width) min-height - the minimum height (useful when the Widget has no fixed height) padding - the padding (has to be this format: TOP RIGHT BOTTOM LEFT or just one number to set the same padding in all directions) padding-top - the padding at the top (default is 0.0 ) padding-right - the padding at the right (default is 0.0 ) padding-bottom - the padding at the bottom (default is 0.0 ) padding-left - the padding at the left (default is 0.0 ) margin - the margin (has to be this format: TOP RIGHT BOTTOM LEFT or just one number to set the same margin in all directions) margin-top - the margin at the top (default is 0.0 ) margin-right - the margin at the right (default is 0.0 ) margin-bottom - the margin at the bottom (default is 0.0 ) margin-left - the margin at the left (default is 0.0 ) alignment-x - the horizontal anchor point of the widget - either left , center or right (default is left ) alignment-y - the vertical anchor point of the widget - either top , center or bottom (default is top ) use-floating-point-position - if the position should use Float instead of Integer (default is false in Vanilla- and true in Fancy-Theme) fit-outer - if fit-content should be applied to the outer instead of the inner bounds of the children (default is false ) box-sizing - how the width and height should be calculated - either content-box or border-box (default is content-box )","title":"Positioning (Bounds)"},{"location":"pages/addon/activities/widgets/#visual","text":"animation-duration - the duration of the animation - in milliseconds (default is 0 ) animation-timing-function - how animations should be interpolated - either linear , ease-in-out , ease-in or ease-out (default is ease-in-out ) background-color - the color of the background (default is 0, set to 0 to disable) background-dirt-brightness - the brightness of the dirt background (default is 32 ) filter - filters that should be applied - possible are blur(RADIUS) and stencil-background font-weight - the weight of the font opacity - the opacity - has to be between 0.0 and 1.0 (default is 1.0 ) render-children - if the children should be rendered (default is true ) renderer - which ThemeRenderer the Widget uses scale - the scale in which the Widget is rendered (default is 1.0 ) visible - if the widget is visible or not (default is true )","title":"Visual"},{"location":"pages/addon/activities/widgets/#behavioral","text":"always-focused - if the Widget should always have the attribute FOCUSED (default is false ) background-always-dirt - if the background should always stay dirt, even if ingame (default is false ) background-dirt-shift - the shift of the dirt background draggable - if the Widget can be dragged (default is false ) interactable - if the widget can be interacted with (default is true ) mouse-render-distance - in which distance to your mouse the Widget will get visible (default is 0.0 , set to 0.0 to disable) pressable - if clicking the widget fires the Pressable callback (default is true ) priority-layer - depending on what is set the Widget will be rendered before everything else or after - either very-back , back , normal , front , very-front (default is normal ) stencil - if the widget content should not be able out of bounds (default is false )","title":"Behavioral"},{"location":"pages/addon/activities/widgets/#list-widget","text":"The ListWidget is the parent of every list like Widget. The Widget has no own LSS properties.","title":"List Widget"},{"location":"pages/addon/activities/widgets/#simple-widget","text":"The SimpleWidget inherits AbstractWidget and removes the generic. The Widget has no own LSS properties.","title":"Simple Widget"},{"location":"pages/addon/activities/widgets/#wrapped-widget","text":"The WrappedWidget is a \"pseudo Widget\" that wraps around its child and acts like it. The Widget has no LSS properties as it redirects everything to its child. deprecated!","title":"Wrapped Widget"},{"location":"pages/addon/features/commands/","text":"todo: write wiki, see nobob, voicechat or the example addon if needed","title":"Create Commands"},{"location":"pages/addon/features/config/","text":"From using our predefined setting widgets over creating your own, to a few things that didn't fit in with the rest. This page will show you everything there is to know about our configuration system. Create a Basic Configuration You can create your configuration by creating a new class and inheriting AddonConfig . This superclass requires you to implement the enabled method, as we want to allow servers to disable every addon they want. The only thing you always need to keep in mind while creating a configuration besides the type you need to inherit is that you need to use the ConfigProperty type for your settings, but just for specific types that you might want to use. More on which types you can use by default here . For any other types, use the type itself without declaring it as an argument on ConfigProperty . To create a setting that represents if your addon is enabled or not, you need to create a new field with the type ConfigProperty . Now add the type of your setting, in this case, Boolean as boolean. Now instantiate this property by declaring a new ConfigProperty with the default value as the argument, well use true as the default value. The result would look like this ConfigProperty<Boolan> enabled = new ConfigProperty<>(true) . Now, if we want to use this property in an event, we'll get the property (preferably by its getter) and call get() . This will get us the value of the property. You can only use various types for your ConfigProperty by default. The current valid types are: String Character Boolean Integer Long Double Float Short Byte any Enum Key MouseButton ResourceLocation Using Predefined Setting Widgets The following content lists all of our Setting Widgets that will be served by using the Addon API, with possible arguments (brackets surround optional arguments), compatible types, and a short description that you can create via an annotation: Switch Widget Annotation: SwitchSetting Arguments: none Compatible Type: Boolean Description: Slider Widget Annotation: SliderSetting Arguments: min - smallest value possible, max - biggest value possible, ( steps - the amount of how much the value will increase/decrease on each move - default is 1) Compatible Types: Integer , Float , Double , Short , Byte , Long Description: Text Field Widget Annotation: TextFieldSetting Arguments: ( maxLength - the maximal length of the string entered) Compatible Type: String Description: Key Bind Widget Annotation: KeyBindSetting Arguments: none Compatible Type: Key Description: Multi Key Bind Widget Annotation: MultiKeyBindSetting Arguments: none Compatible Type: Key[] Description: Color Picker Widget Annotation: ColorPickerSetting Arguments: ( alpha - whether the user should be able to change the transparency - default is false) Compatible Type: Integer Description: Dropdown Widget Annotation: DropdownSetting Arguments: none Compatible Types: any enum Description: Button Widget Annotation: ButtonSetting Arguments: ( text - a String that will be displayed - default is \"\"), ( translation - the key to a translation within your localization files, default is \"\") Compatible Types: any public method, not ConfigProperty Description: Addon Activity Widget Annotation: AddonActivityWidget Arguments: ( text - a String that will be displayed - default is \"\"), ( translation - the key to a translation within your localization files, default is \"\") Compatible Types: any public method that returns an Activity , not ConfigProperty Description: Further Customize the Settings In addition to using predefined widgets for your settings, you also have a few other options to customize them. The following points are not very precisely explained, but you can see everything from the following subsections and most of the subsections before in this section . Create Sections You can create sections in your settings; you just have to add the annotation @SettingSection above the first field that you want to have in said section. Now all you have to do is set the identifier as the annotation's parameter and add it to your internationalization file. Create Sub Settings If you want more structure in your settings but don't want to use Sections, you can create sub-settings that can be accessed via a button. Just create a new class, and let it inherit from Config . Add a field with the same type in your configuration (just the type, not a ConfigProperty ) and create a new instance of said class. You might have noticed that you don't have to use the AddonConfig superclass for sub-settings. The AddonConfig class is required for your main configuration but not for sub-settings. If you want to display more than just the advanced button (the button that lets you access the sub-settings), add the @ParentSwitch annotation to the most important switch in your sub-settings. Use Icons for Settings To display icons in front of your settings, you'll need to declare a sprite texture with the @SpriteTexture annotation. Set the name of your file as the value of the annotation (the base path is assets/NAMESPACE/themes/THEME/textures/sprite , while the namespace is the namespace you set in your build.gradle.kts and the theme to the current theme. If you want your icons to be visible in all themes, put the texture in the vanilla theme). More on sprite textures here . Example of the Previous Sections These are some example files showing a few of the functions mentioned before. ExampleConfiguration ExampleSubSetting ExampleEnum en_us.json Result @ConfigName ( \"settings\" ) @SpriteTexture ( \"example_sprite.png\" ) public class ExampleConfiguration extends AddonConfig { @SpriteSlot ( x = 1 , y = 1 ) @SwitchSetting private ConfigProperty < Boolean > enabled = new ConfigProperty <> ( true ); @SettingSection ( \"print\" ) @SpriteSlot ( x = 6 ) @TextFieldSetting private ConfigProperty < String > text = new ConfigProperty <> ( \"Hello World!\" ); @SettingSection ( \"miscellaneous\" ) @SpriteSlot ( x = 1 , y = 3 ) private ExampleSubSettings subSettings = new ExampleSubSettings (); @SpriteSlot ( y = 3 ) @DropdownSetting private ConfigProperty < ExampleEnum > type = new ConfigProperty <> ( ExampleEnum . SCALENE_TRIANGLE ); @MethodOrder ( after = \"text\" ) @SpriteSlot ( x = 2 , y = 6 ) @ButtonSetting ( text = \"Print!\" ) public void print ( Setting setting ) { LabyGuice . getInstance ( ExampleAddon . class ). logger () . info ( setting . getId () + \" was clicked! \" + this . text ); } @Override public ConfigProperty < Boolean > enabled () { return this . enabled ; } } public class ExampleSubSettings extends Config { @ParentSwitch @SpriteSlot ( x = 7 ) @SwitchSetting private ConfigProperty < Boolean > enabled = new ConfigProperty <> ( true ); @SpriteSlot ( x = 1 , y = 6 ) @ColorPickerSetting private ConfigProperty < Integer > labyModColor = new ConfigProperty <> ( new Color ( 10 , 85 , 165 ). getRGB ()); @SpriteSlot ( x = 2 ) @KeyBindSetting private ConfigProperty < Key > keyBind = new ConfigProperty <> ( Key . F ); } public enum ExampleEnum { HEART , CIRCLE , RECTANGLE , TRIANGLE , SCALENE_TRIANGLE ; } { \"example\" : { \"settings\" : { \"name\" : \"ExampleAddon\" , \"enabled\" : { \"name\" : \"Enabled\" }, \"text\" : { \"name\" : \"Text to be Printed\" }, \"print\" : { \"name\" : \"Click Me to Print the Text\" }, \"subSettings\" : { \"name\" : \"Miscellaneous Sub Settings\" , \"labyModColor\" : { \"name\" : \"The LabyMod Color\" }, \"keyBind\" : { \"name\" : \"Key Bind\" } }, \"type\" : { \"name\" : \"Display Type\" , \"heart\" : \"Heart\" , \"circle\" : \"Circle\" , \"rectangle\" : \"Rectangle\" , \"triangle\" : \"Triangle\" , \"scaleneTriangle\" : \"Weird Shape\" }, \"header\" : { \"miscellaneous\" : { \"name\" : \"Miscellaneous\" }, \"print\" : { \"name\" : \"Print!\" } } } } } Create Custom Settings Register Your Own Setting Type todo: write, check chattime Create Custom Setting Widgets todo: write, check chattime","title":"Creating a Configuration"},{"location":"pages/addon/features/config/#create-a-basic-configuration","text":"You can create your configuration by creating a new class and inheriting AddonConfig . This superclass requires you to implement the enabled method, as we want to allow servers to disable every addon they want. The only thing you always need to keep in mind while creating a configuration besides the type you need to inherit is that you need to use the ConfigProperty type for your settings, but just for specific types that you might want to use. More on which types you can use by default here . For any other types, use the type itself without declaring it as an argument on ConfigProperty . To create a setting that represents if your addon is enabled or not, you need to create a new field with the type ConfigProperty . Now add the type of your setting, in this case, Boolean as boolean. Now instantiate this property by declaring a new ConfigProperty with the default value as the argument, well use true as the default value. The result would look like this ConfigProperty<Boolan> enabled = new ConfigProperty<>(true) . Now, if we want to use this property in an event, we'll get the property (preferably by its getter) and call get() . This will get us the value of the property. You can only use various types for your ConfigProperty by default. The current valid types are: String Character Boolean Integer Long Double Float Short Byte any Enum Key MouseButton ResourceLocation","title":"Create a Basic Configuration"},{"location":"pages/addon/features/config/#using-predefined-setting-widgets","text":"The following content lists all of our Setting Widgets that will be served by using the Addon API, with possible arguments (brackets surround optional arguments), compatible types, and a short description that you can create via an annotation:","title":"Using Predefined Setting Widgets"},{"location":"pages/addon/features/config/#switch-widget","text":"Annotation: SwitchSetting Arguments: none Compatible Type: Boolean Description:","title":"Switch Widget"},{"location":"pages/addon/features/config/#slider-widget","text":"Annotation: SliderSetting Arguments: min - smallest value possible, max - biggest value possible, ( steps - the amount of how much the value will increase/decrease on each move - default is 1) Compatible Types: Integer , Float , Double , Short , Byte , Long Description:","title":"Slider Widget"},{"location":"pages/addon/features/config/#text-field-widget","text":"Annotation: TextFieldSetting Arguments: ( maxLength - the maximal length of the string entered) Compatible Type: String Description:","title":"Text Field Widget"},{"location":"pages/addon/features/config/#key-bind-widget","text":"Annotation: KeyBindSetting Arguments: none Compatible Type: Key Description:","title":"Key Bind Widget"},{"location":"pages/addon/features/config/#multi-key-bind-widget","text":"Annotation: MultiKeyBindSetting Arguments: none Compatible Type: Key[] Description:","title":"Multi Key Bind Widget"},{"location":"pages/addon/features/config/#color-picker-widget","text":"Annotation: ColorPickerSetting Arguments: ( alpha - whether the user should be able to change the transparency - default is false) Compatible Type: Integer Description:","title":"Color Picker Widget"},{"location":"pages/addon/features/config/#dropdown-widget","text":"Annotation: DropdownSetting Arguments: none Compatible Types: any enum Description:","title":"Dropdown Widget"},{"location":"pages/addon/features/config/#button-widget","text":"Annotation: ButtonSetting Arguments: ( text - a String that will be displayed - default is \"\"), ( translation - the key to a translation within your localization files, default is \"\") Compatible Types: any public method, not ConfigProperty Description:","title":"Button Widget"},{"location":"pages/addon/features/config/#addon-activity-widget","text":"Annotation: AddonActivityWidget Arguments: ( text - a String that will be displayed - default is \"\"), ( translation - the key to a translation within your localization files, default is \"\") Compatible Types: any public method that returns an Activity , not ConfigProperty Description:","title":"Addon Activity Widget"},{"location":"pages/addon/features/config/#further-customize-the-settings","text":"In addition to using predefined widgets for your settings, you also have a few other options to customize them. The following points are not very precisely explained, but you can see everything from the following subsections and most of the subsections before in this section .","title":"Further Customize the Settings"},{"location":"pages/addon/features/config/#create-sections","text":"You can create sections in your settings; you just have to add the annotation @SettingSection above the first field that you want to have in said section. Now all you have to do is set the identifier as the annotation's parameter and add it to your internationalization file.","title":"Create Sections"},{"location":"pages/addon/features/config/#create-sub-settings","text":"If you want more structure in your settings but don't want to use Sections, you can create sub-settings that can be accessed via a button. Just create a new class, and let it inherit from Config . Add a field with the same type in your configuration (just the type, not a ConfigProperty ) and create a new instance of said class. You might have noticed that you don't have to use the AddonConfig superclass for sub-settings. The AddonConfig class is required for your main configuration but not for sub-settings. If you want to display more than just the advanced button (the button that lets you access the sub-settings), add the @ParentSwitch annotation to the most important switch in your sub-settings.","title":"Create Sub Settings"},{"location":"pages/addon/features/config/#use-icons-for-settings","text":"To display icons in front of your settings, you'll need to declare a sprite texture with the @SpriteTexture annotation. Set the name of your file as the value of the annotation (the base path is assets/NAMESPACE/themes/THEME/textures/sprite , while the namespace is the namespace you set in your build.gradle.kts and the theme to the current theme. If you want your icons to be visible in all themes, put the texture in the vanilla theme). More on sprite textures here .","title":"Use Icons for Settings"},{"location":"pages/addon/features/config/#example-of-the-previous-sections","text":"These are some example files showing a few of the functions mentioned before. ExampleConfiguration ExampleSubSetting ExampleEnum en_us.json Result @ConfigName ( \"settings\" ) @SpriteTexture ( \"example_sprite.png\" ) public class ExampleConfiguration extends AddonConfig { @SpriteSlot ( x = 1 , y = 1 ) @SwitchSetting private ConfigProperty < Boolean > enabled = new ConfigProperty <> ( true ); @SettingSection ( \"print\" ) @SpriteSlot ( x = 6 ) @TextFieldSetting private ConfigProperty < String > text = new ConfigProperty <> ( \"Hello World!\" ); @SettingSection ( \"miscellaneous\" ) @SpriteSlot ( x = 1 , y = 3 ) private ExampleSubSettings subSettings = new ExampleSubSettings (); @SpriteSlot ( y = 3 ) @DropdownSetting private ConfigProperty < ExampleEnum > type = new ConfigProperty <> ( ExampleEnum . SCALENE_TRIANGLE ); @MethodOrder ( after = \"text\" ) @SpriteSlot ( x = 2 , y = 6 ) @ButtonSetting ( text = \"Print!\" ) public void print ( Setting setting ) { LabyGuice . getInstance ( ExampleAddon . class ). logger () . info ( setting . getId () + \" was clicked! \" + this . text ); } @Override public ConfigProperty < Boolean > enabled () { return this . enabled ; } } public class ExampleSubSettings extends Config { @ParentSwitch @SpriteSlot ( x = 7 ) @SwitchSetting private ConfigProperty < Boolean > enabled = new ConfigProperty <> ( true ); @SpriteSlot ( x = 1 , y = 6 ) @ColorPickerSetting private ConfigProperty < Integer > labyModColor = new ConfigProperty <> ( new Color ( 10 , 85 , 165 ). getRGB ()); @SpriteSlot ( x = 2 ) @KeyBindSetting private ConfigProperty < Key > keyBind = new ConfigProperty <> ( Key . F ); } public enum ExampleEnum { HEART , CIRCLE , RECTANGLE , TRIANGLE , SCALENE_TRIANGLE ; } { \"example\" : { \"settings\" : { \"name\" : \"ExampleAddon\" , \"enabled\" : { \"name\" : \"Enabled\" }, \"text\" : { \"name\" : \"Text to be Printed\" }, \"print\" : { \"name\" : \"Click Me to Print the Text\" }, \"subSettings\" : { \"name\" : \"Miscellaneous Sub Settings\" , \"labyModColor\" : { \"name\" : \"The LabyMod Color\" }, \"keyBind\" : { \"name\" : \"Key Bind\" } }, \"type\" : { \"name\" : \"Display Type\" , \"heart\" : \"Heart\" , \"circle\" : \"Circle\" , \"rectangle\" : \"Rectangle\" , \"triangle\" : \"Triangle\" , \"scaleneTriangle\" : \"Weird Shape\" }, \"header\" : { \"miscellaneous\" : { \"name\" : \"Miscellaneous\" }, \"print\" : { \"name\" : \"Print!\" } } } } }","title":"Example of the Previous Sections"},{"location":"pages/addon/features/config/#create-custom-settings","text":"","title":"Create Custom Settings"},{"location":"pages/addon/features/config/#register-your-own-setting-type","text":"todo: write, check chattime","title":"Register Your Own Setting Type"},{"location":"pages/addon/features/config/#create-custom-setting-widgets","text":"todo: write, check chattime","title":"Create Custom Setting Widgets"},{"location":"pages/addon/features/events/","text":"With LabyMod 4 we not only deliver more Events, but they are also very similar to use, like the events of Minecraft server software like Bukkit and BungeeCord. The Most Important Events We deliver a variety of events, but the following are the ones with the most common use cases: Addon Enable Event The AddonEnableEvent is fired right after we detected your addon. This Event is only fired in your addon; you cannot use it to detect other addons. Addon Post Enable Event The exact moment when the AddonPostEnableEvent is fired depends on the current state of LabyMod. Suppose your addon is loaded directly after the game start (for example while in the addon develop environment or when the addon has been installed before). In that case, the Event will be fired as soon as LabyMod itself has been fully initialized. But if your addon is enabled while LabyMod is already initialized (when a user downloads your addon via the addon store), the Event will be fired right after we enabled it. Addon Unload Event The class exists, but the Event won't be fired yet. It can be used to save custom configurations or close open connections to prevent a timeout. Chat Message Send Event The ChatMessageSendEvent is fired when sending a chat message to the server. It can be used to manipulate outgoing messages but also can be canceled. Chat Receive Event The ChatReceiveEvent is fired when a message is registered to be shown in chat. It can be used to manipulate incoming messages. The Event is cancellable. Game Tick Event The GameTickEvent is fired twice every tick. Once with the phase PRE and once with the phase POST . The phase represents the current state of a tick. If it has the phase PRE , it is fired before Minecraft registers the tick to all its different handlers; if it's the POST phase, it is fired after Minecraft itself handled the tick. A tick represents 50 milliseconds (20 ticks per second). Json Config Loader Initialize Event The JsonConfigLoaderInitializeEvent is fired when the configuration loader is initialized. This Event is used to create your own type adapters for your configuration. Network Disconnect Event The NetworkDisconnectEvent will be fired if the connection to a server closes (so either if the user disconnects or gets kicked). Network Login Event The NetworkLoginEvent will be fired as soon as the user connects to a server. Contains the ServerData. Network Server Switch Event The NetworkServerSwitchEvent is fired when the user is already connected to a server but switches to a sub-server (for example, when connected to a proxy and switching from the hub to survival games). Setting Initialize Event The SettingInitializeEvent is fired when an in-game setting was initialized; is used to modify setting Widgets at a later point (adding custom entries to a Dropdown for example). The listener has to be registered before the setting category is added! Every Other Event todo: write Create Your Very Own Events todo: write","title":"Use and Create Events"},{"location":"pages/addon/features/events/#the-most-important-events","text":"We deliver a variety of events, but the following are the ones with the most common use cases:","title":"The Most Important Events"},{"location":"pages/addon/features/events/#addon-enable-event","text":"The AddonEnableEvent is fired right after we detected your addon. This Event is only fired in your addon; you cannot use it to detect other addons.","title":"Addon Enable Event"},{"location":"pages/addon/features/events/#addon-post-enable-event","text":"The exact moment when the AddonPostEnableEvent is fired depends on the current state of LabyMod. Suppose your addon is loaded directly after the game start (for example while in the addon develop environment or when the addon has been installed before). In that case, the Event will be fired as soon as LabyMod itself has been fully initialized. But if your addon is enabled while LabyMod is already initialized (when a user downloads your addon via the addon store), the Event will be fired right after we enabled it.","title":"Addon Post Enable Event"},{"location":"pages/addon/features/events/#addon-unload-event","text":"The class exists, but the Event won't be fired yet. It can be used to save custom configurations or close open connections to prevent a timeout.","title":"Addon Unload Event"},{"location":"pages/addon/features/events/#chat-message-send-event","text":"The ChatMessageSendEvent is fired when sending a chat message to the server. It can be used to manipulate outgoing messages but also can be canceled.","title":"Chat Message Send Event"},{"location":"pages/addon/features/events/#chat-receive-event","text":"The ChatReceiveEvent is fired when a message is registered to be shown in chat. It can be used to manipulate incoming messages. The Event is cancellable.","title":"Chat Receive Event"},{"location":"pages/addon/features/events/#game-tick-event","text":"The GameTickEvent is fired twice every tick. Once with the phase PRE and once with the phase POST . The phase represents the current state of a tick. If it has the phase PRE , it is fired before Minecraft registers the tick to all its different handlers; if it's the POST phase, it is fired after Minecraft itself handled the tick. A tick represents 50 milliseconds (20 ticks per second).","title":"Game Tick Event"},{"location":"pages/addon/features/events/#json-config-loader-initialize-event","text":"The JsonConfigLoaderInitializeEvent is fired when the configuration loader is initialized. This Event is used to create your own type adapters for your configuration.","title":"Json Config Loader Initialize Event"},{"location":"pages/addon/features/events/#network-disconnect-event","text":"The NetworkDisconnectEvent will be fired if the connection to a server closes (so either if the user disconnects or gets kicked).","title":"Network Disconnect Event"},{"location":"pages/addon/features/events/#network-login-event","text":"The NetworkLoginEvent will be fired as soon as the user connects to a server. Contains the ServerData.","title":"Network Login Event"},{"location":"pages/addon/features/events/#network-server-switch-event","text":"The NetworkServerSwitchEvent is fired when the user is already connected to a server but switches to a sub-server (for example, when connected to a proxy and switching from the hub to survival games).","title":"Network Server Switch Event"},{"location":"pages/addon/features/events/#setting-initialize-event","text":"The SettingInitializeEvent is fired when an in-game setting was initialized; is used to modify setting Widgets at a later point (adding custom entries to a Dropdown for example). The listener has to be registered before the setting category is added!","title":"Setting Initialize Event"},{"location":"pages/addon/features/events/#every-other-event","text":"todo: write","title":"Every Other Event"},{"location":"pages/addon/features/events/#create-your-very-own-events","text":"todo: write","title":"Create Your Very Own Events"},{"location":"pages/addon/features/internationalization/","text":"All internationalization files have to be located in the module called core and then down the folder structure src/main/resources/assets/NAMESPACE/i18n/ (\"NAMESPACE\" should be replaced with the namespace you set in your build.gradle.kts ). The default file for internationalization is called en_us.json , as English is the default language. Create Custom Translations You can do more than internationalize your settings. You also have the option to internationalize every other text that the user sees. Any time a Component of the Adventure Library is used, you have the option to just set a raw String via Component.text . Still, you also have the option to use your custom translations by using Component.translatable . Do you have arguments that need to be replaced? Not a problem! We apply String.format on every translation, so you can just use a Format Specifier in your translation (more about String Formatting here ). So, for example instead of using a non-translated String like \"The Addon has a rating of \" + rating + \" Stars!\" , you could put a String like \"The Addon has a rating of %d Stars!\" in your internationalization file and create the Component with Component.translatable(\"example.commands.info.rating\", rating) and the output would be the same. The only difference is that your Addon can be used in many different languages without hard-coding every String. There are two possibilities to get the translated String if you don't want a Component. If you want a string that cannot be null, you call I18n.translate with the translation key and the arguments. The method will return the key if the translation key cannot be found in any internationalization file. Now, if you want to check if the translation key can be found easily, you call I18n.getTranslation with the translation key and possibly arguments. The method will return null if the key cannot be found. As already mentioned, you can internationalize every text the user can see, even the widgets of our Activity system that display text. A list of all widgets delivered with our Addon API can be found here . Support Multiple Languages The language in LabyMod and thus the preferred internationalization file of every Addon will change when switching the language in Minecraft itself. The fallback language always stays en_us . That means if, for example, a user selected German as the language in which Minecraft is displayed, we will search for a file called de_de.json in your Addon. If that file isn't found, we will use the default file and thus the English translations. All official supported languages can be found in this Minecraft Fandom Wiki article . The relevant part of this chart is the In-game Locale Code. Your file has to have the same locale code. Otherwise, we can't identify your file as a match to the intended language.","title":"Internationalize your Addon"},{"location":"pages/addon/features/internationalization/#create-custom-translations","text":"You can do more than internationalize your settings. You also have the option to internationalize every other text that the user sees. Any time a Component of the Adventure Library is used, you have the option to just set a raw String via Component.text . Still, you also have the option to use your custom translations by using Component.translatable . Do you have arguments that need to be replaced? Not a problem! We apply String.format on every translation, so you can just use a Format Specifier in your translation (more about String Formatting here ). So, for example instead of using a non-translated String like \"The Addon has a rating of \" + rating + \" Stars!\" , you could put a String like \"The Addon has a rating of %d Stars!\" in your internationalization file and create the Component with Component.translatable(\"example.commands.info.rating\", rating) and the output would be the same. The only difference is that your Addon can be used in many different languages without hard-coding every String. There are two possibilities to get the translated String if you don't want a Component. If you want a string that cannot be null, you call I18n.translate with the translation key and the arguments. The method will return the key if the translation key cannot be found in any internationalization file. Now, if you want to check if the translation key can be found easily, you call I18n.getTranslation with the translation key and possibly arguments. The method will return null if the key cannot be found. As already mentioned, you can internationalize every text the user can see, even the widgets of our Activity system that display text. A list of all widgets delivered with our Addon API can be found here .","title":"Create Custom Translations"},{"location":"pages/addon/features/internationalization/#support-multiple-languages","text":"The language in LabyMod and thus the preferred internationalization file of every Addon will change when switching the language in Minecraft itself. The fallback language always stays en_us . That means if, for example, a user selected German as the language in which Minecraft is displayed, we will search for a file called de_de.json in your Addon. If that file isn't found, we will use the default file and thus the English translations. All official supported languages can be found in this Minecraft Fandom Wiki article . The relevant part of this chart is the In-game Locale Code. Your file has to have the same locale code. Otherwise, we can't identify your file as a match to the intended language.","title":"Support Multiple Languages"},{"location":"pages/addon/features/version-dependent/","text":"While our API is entirely version-independent for you to use, you might still need to implement some version-dependent things yourself (such as highly niche things, just something we didn't implement). At the current moment, you might implement more yourself, as we're still implementing more and more stuff for you to use version independently. There are two ways to implement version-dependent; different use cases require different ways to implement them. The easiest method is to create an interface or abstract class and implement it in your desired version(s). This will result in the ability that you can control your version-dependent code from the core. The more complex way would be SpongePowered's Mixin. While Mixin is comparatively easy to use, it can be a bit confusing at the beginning, as all new things are. Important Note Please keep in mind that the examples on this page are version dependent. We are showing the examples for Minecraft 1.19.1, so depending on the date you're reading this, recreating the examples might not be possible, we'll try to keep them updated, though, and if we do, we update the version in this note. Access the Minecraft Code \"the Normal Way\" You should only use this method for things you can access without using Reflections, as using Reflections can have a high impact on the performance of the players that use your addon. The use case we will implement in the following example will show how to display messages in the player's chat. We have already implemented this, but it is relatively easy to show and understand. We will first create a new interface in our core - or api module called ExampleChatExecutor and declare a new method void displayMessageInChat(String) . Now we head to the module of the version we want and create a new class called VersionedExampleChatExecutor in our desired package. If there is no folder called src in the module, you'll need to create the following folder structure inside the module: src/main/java/ . Now to the implementation. First, we implement the interface ExampleChatExecutor , and now the most important part: we need to add the annotation Implement to the class and declare ExampleChatExecutor.class as the argument. This will allow you to access the versioned implementation from the core module. Then we'll add the annotation Singleton to the class, as we don't need more than one object of this implementation. At this point, the only missing point is the actual implementation of Minecraft; we'll overwrite the displayMessageInChat method from our interface and create a new Component from our String with Component.literal(message) . Then we access the Chat GUI with Minecraft.getInstance().gui.getChat() and add our component with addMessage(component) . After implementing the ExampleChatExecutor interface, we go back to our core module and head into our ExamplePingCommand that we got from using the addon template. Then we remove the line where we are displaying a gold-colored \"Pong!\" Component get the object of our interface via LabyGuice.getInstance(ExampleChatExecutor.class). We need to get the instance of the interface because we have no access to the VersionedExampleChatExecutor class when not in this specific module. Now, all we need to do is call the displayMessageInChat method from our interface and declare a String as an argument; we'll be using \"Pong!\"` again. After starting LabyMod 4, joining a server, and executing \"/pong\", we'll see a colorless \"Pong!\". Now, if we want that message colored, we need to replace String in our interface with Component . Instead of using Command.literal , we get the ComponentMapper via Laby.labyApi().minecraft().componentMapper() and call toMinecraftComponent(component) . Now our component from the Adventure Component library was mapped to a Minecraft Component, and calling displayMessageInChat(Component.text(\"Pong!\", NamedTextColor.GOLD)) in our Command works like before. Just with our own implementation. Those are the results from this example: ExampleChatExecutor public interface ExampleChatExecutor { void displayMessageInChat ( String message ); void displayMessageInChat ( Component adventureComponent ); } VersionedExampleChatExecutor @Singleton @Implement ( ExampleChatExecutor . class ) public class VersionedExampleChatExecutor implements ExampleChatExecutor { @Override public void displayMessageInChat ( String message ) { Component component = Component . literal ( message ); this . addMessageToChat ( component ); } @Override public void displayMessageInChat ( net . kyori . adventure . text . Component adventureComponent ) { ComponentMapper componentMapper = Laby . labyAPI (). minecraft (). componentMapper (); Component component = ( Component ) componentMapper . toMinecraftComponent ( adventureComponent ); Minecraft . getInstance (). gui . getChat (). addMessage ( component ); } private void addMessageToChat ( Component component ) { Minecraft . getInstance (). gui . getChat (). addMessage ( component ); } } ExamplePingCommand public class ExamplePingCommand extends Command { @Inject private ExamplePingCommand () { super ( \"ping\" , \"pong\" ); } @Override public boolean execute ( String prefix , String [] arguments ) { if ( prefix . equalsIgnoreCase ( \"ping\" )) { this . displayMessage ( Component . text ( \"Ping!\" , NamedTextColor . AQUA )); return false ; } ExampleChatExecutor chatExecutor = LabyGuice . getInstance ( ExampleChatExecutor . class ); chatExecutor . displayMessageInChat ( Component . text ( \"Pong!\" , NamedTextColor . GOLD )); return true ; } } Access the Minecraft Code via Mixin Important Note Please keep in mind that the moment your addon uses Mixins, it requires a restart when downloaded via the addon store. todo: write Inheriting Version Dependent Code todo: write","title":"Write Version Dependent Code"},{"location":"pages/addon/features/version-dependent/#access-the-minecraft-code-the-normal-way","text":"You should only use this method for things you can access without using Reflections, as using Reflections can have a high impact on the performance of the players that use your addon. The use case we will implement in the following example will show how to display messages in the player's chat. We have already implemented this, but it is relatively easy to show and understand. We will first create a new interface in our core - or api module called ExampleChatExecutor and declare a new method void displayMessageInChat(String) . Now we head to the module of the version we want and create a new class called VersionedExampleChatExecutor in our desired package. If there is no folder called src in the module, you'll need to create the following folder structure inside the module: src/main/java/ . Now to the implementation. First, we implement the interface ExampleChatExecutor , and now the most important part: we need to add the annotation Implement to the class and declare ExampleChatExecutor.class as the argument. This will allow you to access the versioned implementation from the core module. Then we'll add the annotation Singleton to the class, as we don't need more than one object of this implementation. At this point, the only missing point is the actual implementation of Minecraft; we'll overwrite the displayMessageInChat method from our interface and create a new Component from our String with Component.literal(message) . Then we access the Chat GUI with Minecraft.getInstance().gui.getChat() and add our component with addMessage(component) . After implementing the ExampleChatExecutor interface, we go back to our core module and head into our ExamplePingCommand that we got from using the addon template. Then we remove the line where we are displaying a gold-colored \"Pong!\" Component get the object of our interface via LabyGuice.getInstance(ExampleChatExecutor.class). We need to get the instance of the interface because we have no access to the VersionedExampleChatExecutor class when not in this specific module. Now, all we need to do is call the displayMessageInChat method from our interface and declare a String as an argument; we'll be using \"Pong!\"` again. After starting LabyMod 4, joining a server, and executing \"/pong\", we'll see a colorless \"Pong!\". Now, if we want that message colored, we need to replace String in our interface with Component . Instead of using Command.literal , we get the ComponentMapper via Laby.labyApi().minecraft().componentMapper() and call toMinecraftComponent(component) . Now our component from the Adventure Component library was mapped to a Minecraft Component, and calling displayMessageInChat(Component.text(\"Pong!\", NamedTextColor.GOLD)) in our Command works like before. Just with our own implementation. Those are the results from this example: ExampleChatExecutor public interface ExampleChatExecutor { void displayMessageInChat ( String message ); void displayMessageInChat ( Component adventureComponent ); } VersionedExampleChatExecutor @Singleton @Implement ( ExampleChatExecutor . class ) public class VersionedExampleChatExecutor implements ExampleChatExecutor { @Override public void displayMessageInChat ( String message ) { Component component = Component . literal ( message ); this . addMessageToChat ( component ); } @Override public void displayMessageInChat ( net . kyori . adventure . text . Component adventureComponent ) { ComponentMapper componentMapper = Laby . labyAPI (). minecraft (). componentMapper (); Component component = ( Component ) componentMapper . toMinecraftComponent ( adventureComponent ); Minecraft . getInstance (). gui . getChat (). addMessage ( component ); } private void addMessageToChat ( Component component ) { Minecraft . getInstance (). gui . getChat (). addMessage ( component ); } } ExamplePingCommand public class ExamplePingCommand extends Command { @Inject private ExamplePingCommand () { super ( \"ping\" , \"pong\" ); } @Override public boolean execute ( String prefix , String [] arguments ) { if ( prefix . equalsIgnoreCase ( \"ping\" )) { this . displayMessage ( Component . text ( \"Ping!\" , NamedTextColor . AQUA )); return false ; } ExampleChatExecutor chatExecutor = LabyGuice . getInstance ( ExampleChatExecutor . class ); chatExecutor . displayMessageInChat ( Component . text ( \"Pong!\" , NamedTextColor . GOLD )); return true ; } }","title":"Access the Minecraft Code \"the Normal Way\""},{"location":"pages/addon/features/version-dependent/#access-the-minecraft-code-via-mixin","text":"Important Note Please keep in mind that the moment your addon uses Mixins, it requires a restart when downloaded via the addon store. todo: write","title":"Access the Minecraft Code via Mixin"},{"location":"pages/addon/features/version-dependent/#inheriting-version-dependent-code","text":"todo: write","title":"Inheriting Version Dependent Code"},{"location":"pages/addon/publishing/publish/","text":"soon","title":"Publish Your Addon"},{"location":"pages/addon/publishing/requirements/","text":"soon","title":"Requirements"},{"location":"pages/addon/setup/first-steps/","text":"First you'll need a Java IDE, as of now we only support IntelliJ IDEA . Then download JDK (Java Development Kit) 17 if you haven't already and install it. Now download or clone our addon template and open it in your preferred IDE. todo: fill with basic information","title":"First Steps"},{"location":"pages/addon/setup/setup/","text":"All you need to do to start your Addon is done. You should be able to start your Addon with LabyMod 4 right after you imported the Gradle project, but are a few things left that you shouldn't forget. To name a few of them: Basic Information : not only those who will test your Addon would benefit from providing some information, but we do too. Some information is crucial to guarantee a seamless experience Understanding the Example : you could start with coding stuff for your Addon, but we've written an example addon to show you the basics of how LabyMod 4 addons work. Provide information about your Addon Head inside the build.gradle.kts and scroll to the bottom. Search for the addon segment and edit the following points: namespace : this attribute has to be unique for everything to work without complications. If you want to publish your Addon, we will check if this namespace is already taken by any other published addon, so nothing to worry about displayName : the display name users will see when they view their installed addons author : the name of your organization or you description : a description that fits your Addon After you have changed these attributes, reload the Gradle project, and you're good to go. Understanding the Basics Head to core\\src\\main\\java in your root project folder. You'll find some examples, starting with the main addon class: ExampleAddon . The Main Class The most important thing about the main addon class is the AddonListener annotation. This annotation allows us to automatically generate the addon.json , basically the identifier of your Addon. That means without this file, LabyMod can't recognize your Addon, and thus it won't start. Now there are two ways to use this main class: With a Superclass that handles the necessary stuff for you (this is what we used in the example) Without anything in the background. Just a bare class, you have to handle almost everything yourself (logic-wise) The Main with the Superclass We've written a Superclass for an easier and more convenient way to develop addons. By inheriting the class LabyAddon , everything is more straightforward. All you have to do is specify your configuration class (in our example, the class ExampleConfiguration , but more about that later) in 3 different places (the parts you need to replace are written in CAPS): after declaring your main class by appending extends LabyAddon<CONFIGURATION> . After doing that, your IDE should either mark the other two places as errors or replace them automatically, but we'll show you anyhow in the head of the getter configurationClass by changing it to Class<CONFIGURATION> in the body of the same getter configuraionClass by changing the returned value to CONFIGURATION.class Looking at the method enable , you'll see we used a method called `registerSettingCategory``. This method registers a new category in the LabyMod Settings, allowing users to enable/disable or configure other things regarding your Addon. Registering commands and listeners can be done by calling registerListener and registerCommand and providing the class (which will then be injected by us with the help of Guice, more on that here ) or by providing the already initialized object. Now the final method we called here is this.logger() , a logger to print information to the console/log. This is nicer than System.out.println() because it is integrated with the Minecraft log. You can print information with .info() , warnings with .warn() or errors with .error() . The Main without the Superclass As already mentioned, you can inherit the class LabyAddon , but you can also do it without it. Important Note While this is possible, we highly recommend creating Addons with our LabyAddon class as it implements some things that make creating addons easier, especially for beginners. This section stays empty for now, it would take too long to describe it, and we have an easier way. The Configuration Now navigate to the class ExampleConfiguration . You'll see that this class inherits AddonConfig . This is necessary for the main configuration, as it requires you to inherit the enabled ConfigProperty. Looking at the class body, you will find a field called enabled with the SwitchSetting annotation. The annotation declares the Widget that you'll find in your settings. In this case, the Widget is a SwitchSettingWidget, which toggles a boolean between on and off. You can find more about configurations here . The Listener Looking into the package org.example.core.listener , you'll find the class ExampleGameTickListener; it does what it says. It listens to the GameTickListener event. You can find a complete guide to our events here . First, we declared a field with our addon main class as type. Then we created a constructor with our main class instance as a parameter and added the @Inject annotation for Guice to be able to find the constructor. Basically, what this class does is, as already mentioned, listen to the GameTickEvent, which is called twice every tick (first one with phase PRE & the second one with phase POST). In this case, we only listen to the PRE phase because we only want the rest called once. Inside the event, we access the field with our addon main instance; with this instance, we are gaining access to the logger we mentioned a few sections above and printing if the Addon is enabled or disabled. The Command With the LabyMod 4 API, you can add your own commands with a simple-to-use command system. More on how to create own commands here . What we do in this class is as simple and basic as the command system in general. We are inheriting the class Command , creating the constructor of our class, and calling the constructor of the superclass with the main prefix of the command (in our case, ping ) and the aliases (in this case, just pong ). Now to the execute method. It is called when, as the name says, the command is executed, and we can handle it. FINISH AFTER THE COMMAND SYSTEM IS FINISHED The Internationalization File Go to the module called core and then navigate down to src/main/resources/assets/example/i18n/ (the example folder has to be named after the namespace you set in your build.gradle.kts ) and you should see a file with the name en_us.json . This is the default file for internationalization, as English is the default language. To dive deeper in the internationalization of LabyMod go to this article . First, we created a new JSON Object called settings , which implies that the following lines are for the settings; after that, we created another Json Object called example , this has to reflect the namespace that you set in your build.gradle.kts . In said Json Object we declared a String with the key name ; this ends up being the name of the Addon, which you'll see on the category button linking to the settings of your Addon in the LabyMod Settings. Now we created another JSON Object with the key enabled , as this is the name of the field in our configuration; you will find another String with the key name . This is the name of the Setting Widget enabled .","title":"Your first LabyMod 4 Addon"},{"location":"pages/addon/setup/setup/#provide-information-about-your-addon","text":"Head inside the build.gradle.kts and scroll to the bottom. Search for the addon segment and edit the following points: namespace : this attribute has to be unique for everything to work without complications. If you want to publish your Addon, we will check if this namespace is already taken by any other published addon, so nothing to worry about displayName : the display name users will see when they view their installed addons author : the name of your organization or you description : a description that fits your Addon After you have changed these attributes, reload the Gradle project, and you're good to go.","title":"Provide information about your Addon"},{"location":"pages/addon/setup/setup/#understanding-the-basics","text":"Head to core\\src\\main\\java in your root project folder. You'll find some examples, starting with the main addon class: ExampleAddon .","title":"Understanding the Basics"},{"location":"pages/addon/setup/setup/#the-main-class","text":"The most important thing about the main addon class is the AddonListener annotation. This annotation allows us to automatically generate the addon.json , basically the identifier of your Addon. That means without this file, LabyMod can't recognize your Addon, and thus it won't start. Now there are two ways to use this main class: With a Superclass that handles the necessary stuff for you (this is what we used in the example) Without anything in the background. Just a bare class, you have to handle almost everything yourself (logic-wise)","title":"The Main Class"},{"location":"pages/addon/setup/setup/#the-main-with-the-superclass","text":"We've written a Superclass for an easier and more convenient way to develop addons. By inheriting the class LabyAddon , everything is more straightforward. All you have to do is specify your configuration class (in our example, the class ExampleConfiguration , but more about that later) in 3 different places (the parts you need to replace are written in CAPS): after declaring your main class by appending extends LabyAddon<CONFIGURATION> . After doing that, your IDE should either mark the other two places as errors or replace them automatically, but we'll show you anyhow in the head of the getter configurationClass by changing it to Class<CONFIGURATION> in the body of the same getter configuraionClass by changing the returned value to CONFIGURATION.class Looking at the method enable , you'll see we used a method called `registerSettingCategory``. This method registers a new category in the LabyMod Settings, allowing users to enable/disable or configure other things regarding your Addon. Registering commands and listeners can be done by calling registerListener and registerCommand and providing the class (which will then be injected by us with the help of Guice, more on that here ) or by providing the already initialized object. Now the final method we called here is this.logger() , a logger to print information to the console/log. This is nicer than System.out.println() because it is integrated with the Minecraft log. You can print information with .info() , warnings with .warn() or errors with .error() .","title":"The Main with the Superclass"},{"location":"pages/addon/setup/setup/#the-main-without-the-superclass","text":"As already mentioned, you can inherit the class LabyAddon , but you can also do it without it. Important Note While this is possible, we highly recommend creating Addons with our LabyAddon class as it implements some things that make creating addons easier, especially for beginners. This section stays empty for now, it would take too long to describe it, and we have an easier way.","title":"The Main without the Superclass"},{"location":"pages/addon/setup/setup/#the-configuration","text":"Now navigate to the class ExampleConfiguration . You'll see that this class inherits AddonConfig . This is necessary for the main configuration, as it requires you to inherit the enabled ConfigProperty. Looking at the class body, you will find a field called enabled with the SwitchSetting annotation. The annotation declares the Widget that you'll find in your settings. In this case, the Widget is a SwitchSettingWidget, which toggles a boolean between on and off. You can find more about configurations here .","title":"The Configuration"},{"location":"pages/addon/setup/setup/#the-listener","text":"Looking into the package org.example.core.listener , you'll find the class ExampleGameTickListener; it does what it says. It listens to the GameTickListener event. You can find a complete guide to our events here . First, we declared a field with our addon main class as type. Then we created a constructor with our main class instance as a parameter and added the @Inject annotation for Guice to be able to find the constructor. Basically, what this class does is, as already mentioned, listen to the GameTickEvent, which is called twice every tick (first one with phase PRE & the second one with phase POST). In this case, we only listen to the PRE phase because we only want the rest called once. Inside the event, we access the field with our addon main instance; with this instance, we are gaining access to the logger we mentioned a few sections above and printing if the Addon is enabled or disabled.","title":"The Listener"},{"location":"pages/addon/setup/setup/#the-command","text":"With the LabyMod 4 API, you can add your own commands with a simple-to-use command system. More on how to create own commands here . What we do in this class is as simple and basic as the command system in general. We are inheriting the class Command , creating the constructor of our class, and calling the constructor of the superclass with the main prefix of the command (in our case, ping ) and the aliases (in this case, just pong ). Now to the execute method. It is called when, as the name says, the command is executed, and we can handle it. FINISH AFTER THE COMMAND SYSTEM IS FINISHED","title":"The Command"},{"location":"pages/addon/setup/setup/#the-internationalization-file","text":"Go to the module called core and then navigate down to src/main/resources/assets/example/i18n/ (the example folder has to be named after the namespace you set in your build.gradle.kts ) and you should see a file with the name en_us.json . This is the default file for internationalization, as English is the default language. To dive deeper in the internationalization of LabyMod go to this article . First, we created a new JSON Object called settings , which implies that the following lines are for the settings; after that, we created another Json Object called example , this has to reflect the namespace that you set in your build.gradle.kts . In said Json Object we declared a String with the key name ; this ends up being the name of the Addon, which you'll see on the category button linking to the settings of your Addon in the LabyMod Settings. Now we created another JSON Object with the key enabled , as this is the name of the field in our configuration; you will find another String with the key name . This is the name of the Setting Widget enabled .","title":"The Internationalization File"},{"location":"pages/cosmetic/","text":"Test.","title":"Test."},{"location":"pages/cosmetic/#test","text":"","title":"Test."}]}